---
title: "Introducci√≥n a la autocorrelaci√≥n espacial"
author:
  - name: Gabriel Andrade Ponce
    url: https://www.researchgate.net/profile/Gabriel-Andrade-Ponce 
    affiliation: Estudiante de Doctorado -Red de Biolog√≠a y Conservaci√≥n de Vertebrados - INECOL
format: 
 html:
   smooth-scroll: true
   self-contained: true
   toc: true
   toc-title: "Contenido"
   toc-location: "left"
   link-external-newwindow: true
   theme: flatly
lang: es
editor: visual
---

[`r icons::fontawesome("twitter")`\@Gatorco_AP](https://twitter.com/Gatorco_AP) [`r icons::fontawesome("github")`\@gpandradep](https://github.com/gpandradep) `r icons::fontawesome("envelope", style = "solid")`gpandradep\@gmail.com

# Bienvenidos ü§üü§ü

En esta p√°gina encontrar√°n la presentaci√≥n y los scripts para un peque√±o ejercicio donde intentaremos entender de que se trata la autocorrelaci√≥n espacial y como verificarla en nuestros datos.

Por favor sigue las instrucciones para descargar los paquetes y scripts.

# Instrucciones üßê

## Instalaci√≥n de paquetes

Usen el siguiente c√≥digo parra instalar los paquetes necesarios. Tambi√©n pueden instalarlos uno por uno.

```{r}
#| eval: false

install.packages(c("tidyverse", # Manejo de datos y gr√°ficas
                   "sp", # Manejo de datos espaciales
                   "sf", # Manejo de datos espaciales
                   "AICcmodavg", # selecci√≥n de modelos 
                   "DHARMa", # Diagn√≥stico de modelos
                   "MASS", # Extensi√≥n para glm nb
                   "pgirmess", #correlogramas
                   "ncf", # correlogramas
                   "gghighlight", # destacar figuras
                   "showtext", # A√±adir texto
                   "ggtext", # markdown ggplot
                   "ggspatial", # objetos espaciales ggplot
                   "leaflet" #mapas interactivos
                   ))

```

## Descargar datos y script

Puedes descargar el proyecto en R que incluye los datos y los scripts. Para ello usa el siguiente boton y descomprime la carpeta donde lo desees

```{r}
#| echo: false
downloadthis::download_link(
  link = "https://github.com/gpandradep/Independencia_espacial/archive/refs/heads/master.zip",
  button_label = "Descargar proyecto",
  button_type = "danger",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```

# Presentaci√≥n üìΩÔ∏è

```{r}
#| echo: false

xaringanExtra::embed_xaringan(url = "slides/slides.html", ratio = "16:9")
```

\

-   [Diapositivas completas](slides/slides.html.html)

# C√≥digo üíª

## Librer√≠as

```{r}
#| warning: false
#| results: hide

library(tidyverse) # Easily Install and Load the 'Tidyverse'
library(sp) # Classes and Methods for Spatial Data
library(sf) # Simple Features for R
library(gghighlight) # Highlight Lines and Points in 'ggplot2'
library(showtext) # Using Fonts More Easily in R Graphs
library(ggtext) # Improved Text Rendering Support for 'ggplot2'
library(ggspatial) # Spatial Data Framework for ggplot2
library(leaflet) # Create Interactive Web Maps with the JavaScript 'Leaflet' Library
library(AICcmodavg) # Model Selection and Multimodel Inference Based on (Q)AIC(c)
library(DHARMa) # Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models
library(MASS) # Support Functions and Datasets for Venables and Ripley's MASS

# Paquetes para correlogramas
library(pgirmess) # Spatial Analysis and Data Mining for Field Ecologists
library(ncf) # Spatial Covariance Functions
font_add_google("Fira Sans", "firasans") # Familia de tipo de letra
showtext_auto()
```

## Cargar datos

```{r}
CTtable <- read.csv("Data/CTtable.csv") %>%  # Base de coordenadas de c√°maras
 dplyr::select(Station, utm_x, utm_y ) # Seleccionar columnas que usaremos


```

```{r}
#| echo: false
knitr::kable(head(CTtable))
```

```{r}
#| message: false
#| warning: false
events_by_species <- read_csv("Data/surveyReport/events_by_species.csv") %>% 
  type.convert(n_events= col_double(), # Convertir tipo de columna
               n_stations= col_double()) %>% # Convertir tipo de columna
  mutate(Sp_n= paste("*",species,"*", " (n= ", n_events, " ) ", sep = "") ) # Columna para los nombres del eje
```

```{r}
#| echo: false
knitr::kable(head(events_by_species))
```

```{r}
freq_reg <- read.csv("Data/surveyReport/events_by_station2.csv") %>% # Datos de registros por estaci√≥n
  filter(Species == "Odocoileus virginianus") %>% # Filtrar especie
  left_join(CTtable, by= "Station") # Unir con la base da c√°maras
```

```{r}
#| echo: false
knitr::kable(head(freq_reg))
```

## Gr√°fico de detecciones

```{r}
#| message: false
#| warning: false
(ndetectionplot <- ggplot(events_by_species, # Datos
                          aes(x= reorder(Sp_n,n_events), #Ordenar sp 
                              y= n_events))+ # No. eventos
    geom_bar(stat= "identity")+  # Geometria
    gghighlight(species %in% c("Odocoileus virginianus"))+ # Se√±alar venados
    coord_flip()+ # Girar ejes
    labs(title = "Tabla de frecuencia de registro de especies", # T√≠tulo
      y= "N√∫mero de registros independientes", # Eje y
      x= NULL)+ # Sin eje x
    theme_minimal()+ # Tema
    theme(text = element_text(family = 'firasans', size = 16), # tipo de letra
      plot.title.position = 'plot', # Marco de posici√≥n
      plot.title = element_text(face = 'bold', # Negrillas 
        margin = margin(t = 2, r = 0, b = 7, l = 0, unit = "mm"), # Margenes
        hjust = 0.5), #posici√≥n central
      axis.text.y= element_markdown())) # It√°lica nombre de especies
```

## Histograma de detecci√≥nes

```{r}
#| warning: false
#| message: false
(hist <- ggplot(freq_reg, aes(x= n_events))+ # Datos
    geom_histogram(binwidth = 3, color= "white")+ # Geometria
    labs(title = " Histograma n√∫mero de detecciones",
      x= "N√∫mero de detecciones",
      y= "Frecuencia") +
    theme_bw()+ # Tema
    theme(text = element_text(family = 'firasans', size = 16), # tipo de letra
          plot.title.position = 'plot', # Marco de posici√≥n
          plot.title = element_text(face = 'bold', # Negrillas 
                                    margin = margin(t = 2, r = 0, b = 7, l = 0, unit = "mm"), # Margenes
                                    hjust = 0.5)))
```

## Mapa de registros

```{r}
#| message: false
#| warning: false
UMA <- st_read("Shape/UMA.shp") # Leer el shape de la UMA
# Es importante verificar que este en la misma proyecci√≥n (CRS)
```

```{r}
#| message: false
#| warning: false
(map <- ggplot(UMA)+ # shape de uma
  geom_sf()+ # Graficar objeto espacial
  geom_point(data= freq_reg, aes(x=utm_x, y=utm_y, # Agregar puntos
                 size= n_events, color= n_events), # Tama√±o y color
             alpha=0.9)+ # Transparencia
  scale_size(range = c(1,20))+ # Escala del radio para los puntos
  labs(title= "Mapa de n√∫mero detecciones venado cola blanca",
       y= "Lat",
       x= "Lon",
       size= "N√∫mero de \ndetecciones",
       color=NULL)+
    annotation_scale(location = "bl", width_hint = 0.5, # Barra de escala
                     line_width=2, tick_height=10) +
    annotation_north_arrow(location = "tr", # Flecha de norte
                           height = unit(2.5, "cm"), width = unit(2.5, "cm"),
                           pad_x = unit(1, "in"), pad_y = unit(0.5, "in"),
                           style = north_arrow_fancy_orienteering)+
  theme_bw()+
    theme(text=element_text(size=15, family = "special"))+
  theme(text = element_text(family = 'firasans', size = 16), # tipo de letra
        plot.title.position = 'plot', # Marco de posici√≥n
        plot.title = element_text(face = 'bold', # Negrillas 
                                  margin = margin(t = 2, r = 0, b = 7, l = 0, unit = "mm"), # Margenes
                                  hjust = 0.5)))
```

## Modelando la frecuencia de registro de venados

Vamos a modelar la frecuencia de registros del venado por medio de un GLM *Poisson*. Uno de los supuestos de los GLMs es que las unidades espaciales son independientes, de manera que vamos a verificarlo. Adicionalmente, vamos a probar algunas covariables que nos ayuden a explicar la distribuci√≥n espacial de los registros. La no inclusi√≥n de una variable importante puede generar patrones en los residuales.

Vamos a cargar una base de datos de covariables

```{r}
#| warning: false
#| message: false
#| 
covs.data<-read.csv("Data/covars.csv", header=TRUE) %>% # covariables
  dplyr::select(-X) # eliminar columna X

covs.data$Cluster<- as.character(covs.data$Cluster) # cluster es categ√≥rica

### Separar las variables n√∫mericas y categ√≥ricas
cov.num <- covs.data %>% 
  dplyr::select(where(is.numeric)) %>% # Seleccionar columnas num√©ricas
  scale() %>%  # estandarizar
  as.data.frame()

cov.fac <- covs.data %>% 
  dplyr::select(where(is.character)) # Seleccionar variables de caracter

### Unir las bases
sp_glmdata <- data.frame(cov.fac, cov.num) %>% # Unir covariables
  right_join(freq_reg, by= "Station")# Unir con la base de rgistros
```

```{r}
#| echo: false
knitr::kable(head(sp_glmdata))
```

Ahora ajustemos algunos modelos

```{r}
#| message: false
#| warning: false

## Modelos lineales generalizados 

# sin variables
m0 <- glm(n_events~ 1, # Formula
          data = sp_glmdata, # datos
          family = "poisson") # tipo de distribuci√≥n

# la frecuencia de registro afectada por la distancia a cultivo
m1 <- glm(n_events~ Dcrops, 
          data = sp_glmdata, family = "poisson")

# la frecuencia de registro afectada por el verdor de la vegetaci√≥n
m2 <- glm(n_events~ MSAVI, 
                    data = sp_glmdata, family = "poisson")

# la frecuencia de registro afectada por la pendiente
m3 <- glm(n_events~ Slope, 
                    data = sp_glmdata, family = "poisson") 
          #family = "poisson")

# la frecuencia de registro afectada por la distancia a poblados
m4 <- glm(n_events~ Dpop_G, 
                    data = sp_glmdata, family = "poisson")


# la frecuencia de registro afectada por el tipo de habitat
m5 <- glm(n_events~ Habitat, 
             data = sp_glmdata, family = "poisson" )
```

Seleccionamos el "mejor" con el criterio de informaci√≥n de Akaike

```{r}
#| message: false
#| warning: false
lista_mods <- list(m0, m1, m2, m3, m4, m5)
mod_names <- c("freq~ 1",
               "freq~ D_cultivos",
               "freq~ MSAVI",
               "freq~ Slope",
               "freq~ D_poblado",
               "freq~ Habitat"
               )

AIC <- aictab(lista_mods, # Lista de modelos
              modnames = mod_names,  # nombres
              second.ord = F, # Seleccionar AIC
              sort = T) # Ordenar por menor valor
```

```{r}
knitr::kable(AIC)
```

Podemos inspeccionar el mejor modelo

```{r}
# para inspeccionar el modelo usar la funci√≥n summary
summary(m5)
```

Dado al car√°cter relativo del AIC es necesario verificar que el mejor modelo es un buen modelo. Un mal ajuste puede ser causado por la existencia de autocorrelaci√≥n en los residuales.

## Residuales del mejor modelo

Debido a que es un GLM de familia poisson los residuales no est√°n definidos como en un modelo lineal simple. La funci√≥n simulateResidual permite obtener una aproximaci√≥n de residuales escalados para este tipo de modelos.

```{r}
#| message: false
# Verificamos visualmente que el modelo cumpla los requisitos de la distribuci√≥n
residuales <- simulateResiduals(fittedModel = m5, plot =F)

plotQQunif(residuales)
```

Creamos un data set con los residuales y las coordenadas

```{r}
# Creamos el data.frame para el correlograma
data_resm5 <- data.frame(res=residuals(residuales), # Residuales que creamos
                         x= sp_glmdata$utm_x,# coordenadas en x
                         y= sp_glmdata$utm_y) # coordenadas en y
```

```{r}
#| echo: false
knitr::kable(head(data_resm5 ))
```

Mapa de los residuales

```{r}
#| message: false
#| warning: false
(map_res <- ggplot(UMA)+ # shape de uma
    geom_sf()+ # Graficar objeto espacial
    geom_point(data= data_resm5, aes(x=x, y=y, # Agregar puntos
                                   size= res, color= res), # Tama√±o y color
               alpha=0.9)+ # Transparencia
    scale_size(range = c(1,15))+ # Escala del radio para los puntos
    labs(title= "Mapa de residuales modelo m5",
         y= "Lat",
         x= "Lon",
         size= "N√∫mero de \ndetecciones",
         color=NULL)+
    annotation_scale(location = "bl", width_hint = 0.5, # Barra de escala
                     line_width=2, tick_height=10) +
    annotation_north_arrow(location = "tr", # Flecha de norte
                           height = unit(2.5, "cm"), width = unit(2.5, "cm"),
                           pad_x = unit(1, "in"), pad_y = unit(0.5, "in"),
                           style = north_arrow_fancy_orienteering)+
    theme_bw()+
    theme(text=element_text(size=15, family = "special"))+
    theme(text = element_text(family = 'firasans', size = 16), # tipo de letra
          plot.title.position = 'plot', # Marco de posici√≥n
          plot.title = element_text(face = 'bold', # Negrillas 
                                    margin = margin(t = 2, r = 0, b = 7, l = 0, unit = "mm"), # Margenes
                                    hjust = 0.5)))
```

## Verificando autocorrelaci√≥n espacial

El test de Moran I b√°sicamente es la extensi√≥n de una prueba de correlaci√≥n de Pearson para las diferentes distancias entre unidades de muestreo. El objetivo es estimar el grado de correlaci√≥n espacial de una misma variable. Cuando ploteamos el valor de I para las diferentes distancias tenemos un correlograma espacial

Hay diferentes paquetes que permiten generar los correlogramas, cada una tiene sus virtudes y puede ser m√°s conveniente o no, dependiendo de la cap√°cidad de programaci√≥n del usuario y los datos.

Primero vamos a generar la matriz de distancia. Para asegurar que cada categor√≠a de distancia tenga suficientes pares se recomienda trabajar con 2/3 de la m√°xima distancia. En este caso la m√°xima distancia es \~ 8km

```{r}
Wdist <- data.frame(x= sp_glmdata$utm_x,
                    y= sp_glmdata$utm_y) %>% 
  dist() %>% 
  as.matrix()
maxd <- 2/3* max(Wdist)
maxd
```

### Paquete *pgirmess*

`pgirmess` llama las funciones de `spdep` con una sintaxis mas amigable, lo que a su vez lo hace menos flexible. Esta aproximaci√≥n asume que la variable de respuesta se distribuye de manera normal para calcular los p valores

```{r}
#| message: false
pgirmess_correg <- pgirmess::correlog(coords = cbind(data_resm5$x, # coordenada x
                                                     data_resm5$y), # coordenada y
                                      z= data_resm5$res, # residuales
                                      method = "Moran", # Tipo dem√©todo
                                      nbclass = NULL) # Autom√°ticamente el n√∫mero de pares
```

```{r}
#| echo: false
knitr::kable(pgirmess_correg)

```

### Paquete ncf

La ventaja del paquete ncf es que permite generar correlogramas usando un test de significancia no param√©trico, por medio simulaciones Monte Carlo.

```{r}
#| message: false
ncf_correg <- ncf::correlog(x=data_resm5$x, # coordenadas en x
                            y=data_resm5$y, # coordenadas en y
                            z=data_resm5$res, # variable de inter√©s,
                            latlon =  FALSE, #formato lat lon
                            na.rm=T, # en caso de NAs
                            increment = 700, # Distancia m√≠nima de unidades
                            resamp=500) # N√∫mero de remuestreos
```

Modificamos data frame para la gr√°fica

```{r}
corbase <- data.frame(coef=ncf_correg$correlation, 
                     dist.class= ncf_correg$mean.of.class, 
                     p.value= ncf_correg$p,
                     n= ncf_correg$n )%>% 
  bind_rows(as.data.frame(pgirmess_correg)) %>% 
  mutate(package= c(rep("ncf", 12), rep("pgirmess",12)),
         p_valor= if_else(p.value<0.025, "significativo", "no-significativo"))
```

```{r}
#| echo: false
knitr::kable(corbase)
```

Generamos nuestro gr√°fico

```{r}
#| message: false
(ggplot(corbase ,aes(x=dist.class, y=coef, group= package))+
    geom_hline(yintercept = 0, linetype= "dashed")+
    geom_line(size=0.9, colour="black")+
    geom_point(aes(fill= package, shape=p_valor), 
               shape= 21, size=5, stroke = 1.5)+
    ylim(-1,1)+
    scale_x_continuous(breaks = seq(0,8000, by=500),limits = c(500,6000))+
    labs(x= "Unidades de distancia (m)", y= " Moran I", 
         title = " Correlograma de residuales",
         colour= "Librer√≠a")+
    theme_classic()+
    theme(text = element_text(family = 'firasans', size = 20), # tipo de letra
          plot.title.position = 'plot', # Marco de posici√≥n
          plot.title = element_text(face = 'bold', # Negrillas 
                                    margin = margin(t = 2, r = 0, 
                                                    b = 7, l = 0, 
                                                    unit = "mm"), # Margenes
                                    hjust = 0.5),
          legend.position = c(0.8, 0.8))) # posici√≥n de la legenda
```

### SP lines con ncf

`ncf` tambi√©n permite ajustar splines cubicas por medio de bootstrap, en este caso no es necesario definir cortes de pares de distancias y permite obtener intervalos de confianza

```{r}
spline <- ncf::spline.correlog(x=data_resm5$x, # coordenadas en x
                               y=data_resm5$y, # coordenadas en y
                               z=data_resm5$res,
                               xmax = maxd, # distancia m√°xima
                               type = "boot",
                               resamp = 500)
```

Podemos hacer un plot de manera muy sencilla con `plot(spline)`, pero como yo soy terco la quiero hacer con ggplot.

Primero extraigo los valores de la gr√°fica

```{r}
spl_dist <- as.data.frame(spline[["boot"]][["boot.summary"]][["predicted"]][["x"]]) %>% 
  t()

sp_base <- spline[["boot"]][["boot.summary"]][["predicted"]][["y"]][c(2,6,10),] %>% t() %>% 
  as_tibble() %>% 
  mutate(dist= spl_dist[,1])
```

```{r}
#| echo: false
knitr::kable(head(sp_base))
```

Ahora si el gr√°fico

```{r}
(splineplot <- ggplot(sp_base, aes(x= dist, y= `0.5`))+
  geom_ribbon(aes(ymin= `0.025`, ymax= `0.975`),
              fill= "lightgray")+
  geom_line(size=1)+
  ylim(-1,1)+
  scale_x_continuous(breaks = seq(0,8000, by=500),
                     limits = c(min(sp_base$dist), max(sp_base$dist)),
                     expand = c(0,0))+
  geom_hline(yintercept = 0, linetype=2)+
  geom_vline(xintercept = 500, linetype=2, colour= "blue", size=0.8)+
  annotate(geom = "curve", x = 900, y = 0.7, xend = 530, yend = 0.5, 
      curvature = .3, arrow = arrow(length = unit(4, "mm")), size=0.8) +
  annotate(geom = "text", x = 930, y = 0.7, size= 5, 
           label = "Distancia m√≠nima", hjust = "left")+
  labs(x= "Unidades de distancia (m)", y= " Moran I", 
       title = " Spatial line de residuales")+
  theme_classic()+
  theme(text = element_text(family = 'firasans', size = 20), # tipo de letra
        plot.title.position = 'plot', # Marco de posici√≥n
        plot.title = element_text(face = 'bold', # Negrillas 
                                  margin = margin(t = 2, r = 0, 
                                                  b = 7, l = 0, 
                                                  unit = "mm"), # Margenes
                                  hjust = 0.5),
        legend.position = c(0.8, 0.8))) # posici√≥n de la legenda
```

Lo que podemos concluir con todas las aproximaciones vistas es que parece ser que no hay una autocorrelaci√≥n espacial fuerte de los residuales de nuestro modelo m5. Esto quiere decir que las desviaciones de la normalidad se deben a otro factor.

### Cambiando especificaci√≥n del modelo

Ajustamos otro modelo que asumen una distribuci√≥n de error \*binomial negativa\*. Con ello nos damos cuenta que el problema era el tipo de distribuci√≥n.

```{r}
m5bn <- glm.nb(n_events~ Habitat, data = sp_glmdata)
```

```{r}
testDispersion(m5bn)
```

```{r}
residuales.bn <- simulateResiduals(fittedModel = m5bn, plot =F)

plotQQunif(residuales.bn)
```

Sorpresa üëΩ

# Esto es el inicio de la aventura

Esto fue un ejercicio sencillo, pero lidiar con la ACS merece realizar diversas lecturas en el tema, conocer los supuestos de las t√©cnicas y aprender a interpretar los resultados.

En caso de encontrar ACS y dependiendo de los objetivos es recomendable usar herramientas como modelos de m√≠nimos cuadrados generalizados (GLS), modelos mixtos, considerar a las coordenadas como covariables o modelos autorregresivos.

# Lecturas recomendadas

```{r}
#| echo: false
knitr::include_graphics("https://d23gn3985hkc32.cloudfront.net/wp-content/uploads/2020/12/252164-DangerousToGoAlone.jpg")

```

-   1- [Fox \*et al.\* 2015. Ecological Statistics: Contemporary theory and application](https://oxford.universitypressscholarship.com/view/10.1093/acprof:oso/9780199672547.001.0001/acprof-9780199672547)

-   2- [Plant 2019. Spatial Data Analysis in Ecology and Agriculture Using R](https://www.routledge.com/Spatial-Data-Analysis-in-Ecology-and-Agriculture-Using-R/Plant/p/book/9780367732325)

-   3- [Dorman \*et al.\* 2007. Methods to account for spatial autocorrelation in the analysis of species distributional data: a review](https://onlinelibrary.wiley.com/doi/10.1111/j.2007.0906-7590.05171.x)

-   4- [Kuhn & Dorman 2012. Less than eight (and a half) misconceptions of spatial analysis](https://onlinelibrary.wiley.com/doi/full/10.1111/j.1365-2699.2012.02707.x)

-   5- [Fletcher & Fortin 2018. Spatial Ecology and Conservation](https://link.springer.com/book/10.1007/978-3-030-01989-1)
